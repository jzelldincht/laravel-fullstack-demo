# Laravel代码异常处理

## 语法错误：ParseError
### 模拟一个错误

在控制器 `modules/Api/Http/Controllers/IndexController.php` 中写入以下错误代码：
```php 
...
    $key = $request->post('name')  // 没有结束的分号，引出 ParseError
    
...
```

### 处理ParseError

modules/Common/Exceptions/Handler.php

```php 
<?php

namespace Modules\Common\Exceptions;

use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;
use Illuminate\Support\Facades\Log;
use Illuminate\Validation\ValidationException;
use Modules\Api\Exceptions\ApiException;
use Modules\Common\Variables\HttpStatus;
use Modules\Common\Variables\ResponseMessage;
use Modules\Common\Variables\ResponseStatus;
use ParseError;
use Throwable;

class Handler extends ExceptionHandler
{
    /**
     * A list of the exception types that are not reported.
     *
     * @var array<int, class-string<Throwable>>
     */
    protected $dontReport = [
        //
    ];

    /**
     * A list of the inputs that are never flashed for validation exceptions.
     *
     * @var array<int, string>
     */
    protected $dontFlash = [
        'current_password',
        'password',
        'password_confirmation',
    ];

    /**
     * Register the exception handling callbacks for the application.
     *
     * @return void
     */
    public function register()
    {
        $this->reportable(function (Throwable $e) {
            //
        });
    }

    public function render($request, Throwable $e)
    {
        // 判断是否是 api/xx/xx  的路由
        if($request->is('api/*')) {

            // 解析上面的 ParseError
            if($e instanceof ParseError)
            {
                $log_data = [];
                $log_data['message'] = $e->getMessage();
                $log_data['code'] = $e->getCode();
                $log_data['file'] = $e->getFile();
                $log_data['line'] = $e->getLine();

                // TODO: 如果是代码或框架中的错误，我们需要手动记录日志
                // Log::error(json_encode($log_data));

                return response()->json([
                    'status' => ResponseStatus::INTERNAL_SERVER_ERROR,
                    'message' => ResponseMessage::INTERNAL_SERVER_ERROR,
                ], HttpStatus::INTERNAL_SERVER_ERROR);
            }

            // 自定义的Api异常，接管Api模块的所有异常，如数据库等
            if($e instanceof ApiException) {
                $message = $e->getMessage();
                $status = $e->getCode();

                return response()->json([
                    'status' => $status,
                    'message' => $message,
                ], HttpStatus::BAD_REQUEST);
            }

            // 用户输入验证异常
            if($e instanceof ValidationException)
            {
                $message = $e->validator->errors()->first();

                return response()->json([
                    'status' => ResponseStatus::BAD_REQUEST,
                    'message' => $message,
                ], HttpStatus::BAD_REQUEST);
            }
        }


        return parent::render($request, $e); // TODO: Change the autogenerated stub
    }
}

```

可以看到上面，我们解析了ParseError时的错误提示，同时有个 `TODO` 表示需要手动写入日志，日志我们会后面再填坑。

## 异常错误的处理

除了上面的错误处理，还有一些常见的异常，我们来统一处理下。
```php 
## 数据库错误
### InvalidArgumentException 数据库连接错误
### ModelNotFoundException 数据模型错误
### QueryException 数据库查询错误

## 服务器错误
### ReflectionException 异常映射
### RuntimeException 运行时异常，未检查异常
### ErrorException 框架运行出错
```

### modules/Common/Variables/ResponseMessage.php

```php 
<?php

namespace Modules\Common\Variables;

/**
 * 该类保存自定义返回错误信息
 * 模块或应用自定义状态码对应的错误信息
 */
class ResponseMessage
{

    const INVALID_REQUEST = 'Invalid Request.';// Invalid request.
    const UNAUTHORIZED = 'Authorization Required.';// Authorization required
    const INTERNAL_SERVER_ERROR = 'Internal Server Error.'; // Internal server error.
    const NOT_FOUND = 'Not Found';// Not found
    const OK = 'OK';// Successfully

    const PARSE_ERROR = 'Syntax Error.';// 语法错误

    const REFLECTION_EXCEPTION = 'Reflection Exception.';// 异常映射
    const RUNTIME_EXCEPTION = 'Runtime Exception.';// 运行期异常 运行时异常 运行异常 未检查异常
    const ERROR_EXCEPTION = 'Error Exception.';// 框架运行出错

    const INVALID_ARGUMENT_EXCEPTION = 'Invalid argument exception.';// 数据库链接问题
    const QUERY_EXCEPTION = 'Query Exception.';// 数据库DB Query错误
    const MODEL_NOT_FOUND_EXCEPTION = 'Model Not Found Exception.';// 数据库链接问题
    const PDO_EXCEPTION = 'PDO Exception.';// PDO异常

    const COMMON_EXCEPTION = 'Network Error.';// 通用异常，不方便显示异常信息时，展示此信息。

}

```

### modules/Common/Variables/ResponseStatus.php

```php 
<?php

namespace Modules\Common\Variables;

/**
 * 该类保存自定义返回状态码
 * 模块或应用自定义状态码
 */
class ResponseStatus
{
    const BAD_REQUEST = 40000;// Invalid request.
    const UNAUTHORIZED = 40100;// Authorization required
    const INTERNAL_SERVER_ERROR = 50000; // Internal server error.
    const NOT_FOUND = 40400;// Not found
    const OK = 20000;// Successfully

    const PARSE_ERROR = 50001;// 语法错误
    const REFLECTION_EXCEPTION = 50002;// 异常映射
    const RUNTIME_EXCEPTION = 50003;// 运行期异常 运行时异常 运行异常 未检查异常
    const ERROR_EXCEPTION = 50004;// 框架运行出错

    const INVALID_ARGUMENT_EXCEPTION = 60001;// 数据库链接问题
    const QUERY_EXCEPTION = 60002;// 数据库DB Query错误
    const MODEL_NOT_FOUND_EXCEPTION = 60003;// 数据库模型未找到
    const PDO_EXCEPTION = 60004;// PDO异常

    const COMMON_EXCEPTION = 10000;// 通用异常，不方便显示异常信息时，展示此信息。
}

```

### 改造 modules/Common/Exceptions/Handler.php

```php 
<?php

namespace Modules\Common\Exceptions;

use ErrorException;
use Illuminate\Database\Eloquent\ModelNotFoundException;
use Illuminate\Database\QueryException;
use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;
use Illuminate\Http\JsonResponse;
use Illuminate\Validation\ValidationException;
use InvalidArgumentException;
use Modules\Api\Exceptions\ApiException;
use Modules\Common\Variables\HttpStatus;
use Modules\Common\Variables\ResponseMessage;
use Modules\Common\Variables\ResponseStatus;
use ParseError;
use PDOException;
use ReflectionException;
use RuntimeException;
use Throwable;

class Handler extends ExceptionHandler
{
    protected $exceptionStatus;
    protected $exceptionMessage;

    /**
     * 允许检测异常的异常类
     * 索引1为异常类
     * 索引2为异常错误码
     * 索引3为异常错误信息
     * @var string[]
     */
    protected $exceptionClasses = [
        [
            'class' => ParseError::class,
            'status' => ResponseStatus::PARSE_ERROR,
            'message' => ResponseMessage::PARSE_ERROR,
            'code' => HttpStatus::INTERNAL_SERVER_ERROR,
        ],
        [
            'class' => InvalidArgumentException::class,
            'status' => ResponseStatus::INVALID_ARGUMENT_EXCEPTION,
            'message' => ResponseMessage::INVALID_ARGUMENT_EXCEPTION,
            'code' => HttpStatus::INTERNAL_SERVER_ERROR,
        ],
        [
            'class' => ModelNotFoundException::class,
            'status' => ResponseStatus::MODEL_NOT_FOUND_EXCEPTION,
            'message' => ResponseMessage::MODEL_NOT_FOUND_EXCEPTION,
            'code' => HttpStatus::INTERNAL_SERVER_ERROR,
        ],
        [
            'class' => QueryException::class,
            'status' => ResponseStatus::QUERY_EXCEPTION,
            'message' => ResponseMessage::QUERY_EXCEPTION,
            'code' => HttpStatus::INTERNAL_SERVER_ERROR,
        ],
        [
            'class' => ReflectionException::class,
            'status' => ResponseStatus::REFLECTION_EXCEPTION,
            'message' => ResponseMessage::REFLECTION_EXCEPTION,
            'code' => HttpStatus::INTERNAL_SERVER_ERROR,
        ],
        [
            'class' => RuntimeException::class,
            'status' => ResponseStatus::RUNTIME_EXCEPTION,
            'message' => ResponseMessage::RUNTIME_EXCEPTION,
            'code' => HttpStatus::INTERNAL_SERVER_ERROR,
        ],
        [
            'class' => ErrorException::class,
            'status' => ResponseStatus::ERROR_EXCEPTION,
            'message' => ResponseMessage::ERROR_EXCEPTION,
            'code' => HttpStatus::INTERNAL_SERVER_ERROR,
        ],
        [
            'class' => ApiException::class,
            'status' => ResponseStatus::BAD_REQUEST,
            'message' => null,
            'code' => HttpStatus::BAD_REQUEST,
        ],
        [
            'class' => ValidationException::class,
            'status' => ResponseStatus::BAD_REQUEST,
            'message' => null,
            'code' => HttpStatus::BAD_REQUEST,
        ],
    ];

    /**
     * A list of the exception types that are not reported.
     *
     * @var array<int, class-string<Throwable>>
     */
    protected $dontReport = [
        //
    ];

    /**
     * A list of the inputs that are never flashed for validation exceptions.
     *
     * @var array<int, string>
     */
    protected $dontFlash = [
        'current_password',
        'password',
        'password_confirmation',
    ];

    /**
     * Register the exception handling callbacks for the application.
     *
     * @return void
     */
    public function register()
    {
        $this->reportable(function (Throwable $e) {
            //
        });
    }

    /**
     * 判断是否存在于抛出异常处理的类，并根据相应的类返回对应的错误码和错误信息
     * @param Throwable $e
     * @return false|JsonResponse
     */
    protected function errorException(Throwable $e)
    {
        foreach ($this->exceptionClasses as $index => $exception_class) {

            if ($e instanceof $exception_class['class']) {
                // 错误的具体信息，保存于 data 中
                $exception_data = [];

                // 初始化错误信息为通用错误信息
                $message = ResponseMessage::COMMON_EXCEPTION;
                $status = ResponseStatus::COMMON_EXCEPTION;

                // 如果app.debug为真，则显示详细的信息，否则返回通用的错误提示
                if (config('app.debug') == true) {

                    // 优先判断有没有 getModel() 方法
                    // getModel() 会覆盖 getMessage()
                    if (method_exists($e, 'getModel') && $e->getModel()) {
                        $message = $e->getModel();
                    } else if (method_exists($e, 'getMessage') && $e->getMessage()) {
                        $message = $e->getMessage();
                    } else if (method_exists('apiMessage') && $e->apiMessage()) {
                        // ApiException 时返回$e->message;
                        $message = $e->apiMessage();
                    }

                    // 是否存在 getSql() 方法
                    if (method_exists($e, 'getSql')) {
                        $exception_data['sql'] = $e->getSql();
                    }

                    if($e->getCode() && $e->getCode()) {
                        $exception_data['code'] = $e->getCode();// ApiException 时返回$e->code;
                    }

                    $exception_data['file'] = $e->getFile();
                    $exception_data['line'] = $e->getLine();
                    $exception_data['message'] = $message;
                }

                if (method_exists($e, 'apiStatus') && $e->apiStatus()) {
                    $exception_class['status'] = $e->apiStatus();// ApiException 时返回$e->code;
                    $exception_data = [];// 如果为 ApiException，不传递 data
                }

                // 如果监测到是 validator 属性则获取其 errors 内容为错误信息
                if(property_exists($e, 'validator')) {
                    $message = $e->validator->errors()->first();
                    $exception_data = [];// 如果为 ValidatorException，不传递 data
                }

                return response()->json(array_merge([
                    'status' => $exception_class['status'],
                    'message' => $message,
                ], empty($exception_data) ? [] : ['data' => $exception_data,]), $exception_class['code']);

            }
        }

        return false;
    }

    public function render($request, Throwable $e)
    {
        // 判断是否是 api/xx/xx  的路由
        if ($request->is('api/*')) {

            $result = $this->errorException($e);
            if ($result) {
                return $result;
            }
        }


        return parent::render($request, $e); // TODO: Change the autogenerated stub
    }
}

```
